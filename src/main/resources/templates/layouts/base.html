<!DOCTYPE html>
<html lang="es" xmlns:th="http://www.thymeleaf.org" xmlns:layout="http://www.ultraq.net.nz/thymeleaf/layout">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <!-- Título por defecto; las páginas pueden sobreescribir con <title layout:fragment="title"> -->
  <title layout:fragment="title" th:text="${pageTitle} ?: 'Residuos Sólidos - Frontera de la Paz'">Residuos Sólidos - Frontera de la Paz</title>

  <link rel="icon" href="/favicon.svg" type="image/svg+xml">
  <meta name="description" th:content="${pageDescription != null ? pageDescription : 'Gestión de residuos sólidos en la frontera de la paz'}">

  <!-- Tipografía Nunito: preconnect + fallback a Google Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Nunito:wght@300;400;600;700;800&display=swap" rel="stylesheet">
  <!-- Google Material Symbols (iconos gratuitos) -->
  <link href="https://fonts.googleapis.com/css2?family=Material+Symbols+Rounded:opsz,wght,FILL,GRAD@20..48,300..700,0..1,-50..200" rel="stylesheet">
  <!-- Self-hosted Nunito (woff2) -->

  <!-- Preload recursos críticos -->
  <!-- Preload de CSS críticos (sin fuentes locales) -->
  <link rel="preload" th:href="@{/css/typography.css(v=2)}" href="/css/typography.css?v=2" as="style">
  <link rel="preload" th:href="@{/css/index.css(v=2)}" href="/css/index.css?v=2" as="style">
  <link rel="preload" th:if="${heroImage != null and !#strings.isEmpty(heroImage)}" th:href="${heroImage}" as="image">

  <!-- Tipografía y estilos globales/componentes -->
  <!-- Tailwind via CDN. Debe ir antes de los estilos personalizados. -->
  <script src="https://cdn.tailwindcss.com"></script>
  <script>
    // Tailwind config sin plugins deprecated (line-clamp incluido por defecto en v3.3+)
    tailwind.config = {}
  </script>
  <link rel="stylesheet" th:href="@{/css/typography.css(v=2)}" href="/css/typography.css?v=2">
  <link rel="stylesheet" th:href="@{/css/index.css(v=2)}" href="/css/index.css?v=2">
  <link rel="stylesheet" th:href="@{/css/button.css(v=1)}" href="/css/button.css?v=1" media="print" onload="this.media='all'">
  <link rel="stylesheet" th:href="@{/css/card.css(v=1)}" href="/css/card.css?v=1" media="print" onload="this.media='all'">
  <link rel="stylesheet" th:href="@{/css/badge.css(v=1)}" href="/css/badge.css?v=1" media="print" onload="this.media='all'">
  
  
  
  <!-- Punto de extensión para CSS extra por página -->
  <th:block layout:fragment="head-extra"></th:block>
  
  <!-- Hotwire Turbo Drive: navegación rápida sin recargar assets -->
  <script src="https://cdn.jsdelivr.net/npm/@hotwired/turbo@7.3.0/dist/turbo.es2017-umd.js" defer></script>
  <script>
    // Opcional: reducir el delay de la barra de progreso
    document.addEventListener('DOMContentLoaded', function() {
      try { Turbo.setProgressBarDelay(100); } catch(e) {}
    });
  </script>
  
  <!-- Debug layout outlines via class on body -->
  <style>
    /* Outline fino para todos los elementos */
    body.debug-outlines * { outline: 1px solid rgba(0,0,0,0.25) !important; }
    /* Outline más notorio para contenedores clave */
    body.debug-outlines .container, body.debug-outlines .hero, body.debug-outlines .hero-media, body.debug-outlines .hero-content, body.debug-outlines .hero-content-inner,
    body.debug-outlines .steps, body.debug-outlines .step, body.debug-outlines .notes-header, body.debug-outlines .notes-grid, body.debug-outlines .card, body.debug-outlines .card-media, body.debug-outlines .card-body,
    body.debug-outlines .lang-switch, body.debug-outlines header, body.debug-outlines main, body.debug-outlines footer, body.debug-outlines nav, body.debug-outlines section, body.debug-outlines article, body.debug-outlines aside {
      outline: 2px solid #000 !important;
    }
    /* No dibujar outline sobre la capa de overlay del hero */
    body.debug-outlines .overlay { outline: none !important; }

    /* Overlay de grilla de 12 columnas (bajo nivel) */
    #gridOverlay { display: none; }
    body.grid-overlay-on #gridOverlay {
      display: block;
      position: fixed;
      inset: 0;
      z-index: 30; /* Reducido de 40 para no tapar footer */
      pointer-events: none;
    }
    /* Wrapper centrado que imita mx-auto px-4 sm:px-6 lg:px-8. Ancho controlado por variable. */
    #gridOverlay .grid-overlay-inner {
      height: 100%;
      /* Por defecto centrado por max-width (mantenemos como fallback) */
      margin-left: auto;
      margin-right: auto;
      padding-left: 1rem;   /* px-4 */
      padding-right: 1rem;  /* px-4 */
      max-width: var(--grid-max, 80rem); /* por defecto 7xl */
      width: 100%;
      /* Overlay simple: líneas cada 4 columnas (col-span-4) */
      background-image: 
        linear-gradient(to right, rgba(255,0,0,0.2) 0, rgba(255,0,0,0.2) 1px, transparent 1px, transparent 33.333%),
        linear-gradient(to right, transparent 33.333%, rgba(255,0,0,0.2) 33.333%, rgba(255,0,0,0.2) calc(33.333% + 1px), transparent calc(33.333% + 1px), transparent 66.666%),
        linear-gradient(to right, transparent 66.666%, rgba(255,0,0,0.2) 66.666%, rgba(255,0,0,0.2) calc(66.666% + 1px), transparent calc(66.666% + 1px));
    }
    /* Modo Full: columnas a todo el viewport, respetando padding para gutters */
    #gridOverlay.full .grid-overlay-inner {
      max-width: none;
    }
    @media (min-width: 640px) { /* sm */
      #gridOverlay .grid-overlay-inner { padding-left: 1.5rem; padding-right: 1.5rem; }
    }
    @media (min-width: 1024px) { /* lg */
      #gridOverlay .grid-overlay-inner { padding-left: 2rem; padding-right: 2rem; }
    }
  </style>
  
  <!-- Debug layout outlines: activar con ?debug=1 -->
  <th:block th:if="${param.debug != null}">
    <style>
      /* Borde fino para todos los elementos */
      * { outline: 1px solid rgba(0,0,0,0.25) !important; }
      /* Borde más notorio para bloques clave */
      .container, .hero, .hero-media, .hero-content, .hero-content-inner,
      .steps, .step, .notes-header, .notes-grid, .card, .card-media, .card-body,
      .lang-switch, header, main, footer, nav, section, article, aside {
        outline: 2px solid #000 !important;
      }
    </style>
  </th:block>
</head>
<body>
  <!-- Aviso global de testing (delgado, alineado a la izquierda, sin espacio superior) -->
  <div class="w-full bg-emerald-700 text-white">
    <div class="mx-auto px-4 sm:px-6 lg:px-8">
      <button id="testingNoticeBtn" type="button"
              class="w-full py-1 text-left text-[11px] sm:text-xs leading-none flex items-center gap-2 cursor-pointer hover:bg-emerald-800/40 focus:outline-none focus:ring-2 focus:ring-white/60 rounded"
              aria-controls="testingModal" aria-haspopup="dialog">
        <span class="material-symbols-rounded text-white" aria-hidden="true">warning</span>
        <span>Sistema en desarrollo</span>
      </button>
    </div>
  </div>

  <!-- Contenido de la página -->
  <main id="app" layout:fragment="content">
    <!-- El contenido de cada página se inyectará aquí -->
  </main>
  
  <!-- Modal reutilizable: aviso de testing -->
  <th:block th:replace="~{fragments/ui/modal :: modal(id='testingModal', title='Sitio en etapa de testing', message='Este sistema está en etapa de testing. Por favor, no ingreses datos personales ni información sensible.<br><br>Ten en cuenta que los datos y acciones pueden resetearse o ser eliminados sin previo aviso.')}" />
  
  <!-- Capa de overlay de grilla (bajo nivel) -->
  <div id="gridOverlay" aria-hidden="true"><div class="grid-overlay-inner"></div></div>

  <!-- Scripts globales (ligeros) -->
  <!-- Cache-busting para asegurar última versión del language-switcher -->
  <script th:src="@{/js/language-switcher.js(v=4)}" src="/js/language-switcher.js?v=4" defer></script>
  <script>
    document.addEventListener('DOMContentLoaded', function(){
      var btn = document.getElementById('testingNoticeBtn');
      var modal = document.getElementById('testingModal');
      if (btn && modal) {
        btn.addEventListener('click', function(){ modal.classList.remove('hidden'); });
        modal.addEventListener('click', function(e){
          var closeAttr = e.target.getAttribute && e.target.getAttribute('data-close');
          if (closeAttr === 'testingModal') modal.classList.add('hidden');
        });
      }
    });
  </script>
  
  <script>
    (function() {
      const KEY = 'debugOutlines';
      const btn = document.getElementById('debugToggleBtn');
      const body = document.body;

      function setState(enabled) {
        if (enabled) {
          body.classList.add('debug-outlines');
          if (btn) { btn.setAttribute('aria-pressed', 'true'); btn.textContent = 'Debug: ON'; }
        } else {
          body.classList.remove('debug-outlines');
          if (btn) { btn.setAttribute('aria-pressed', 'false'); btn.textContent = 'Debug: OFF'; }
        }
        try { localStorage.setItem(KEY, enabled ? '1' : '0'); } catch (e) {}
      }

      // Init from localStorage or URL ?debug=1
      let init = false;
      try { init = localStorage.getItem(KEY) === '1'; } catch (e) {}
      const urlHasDebug = new URLSearchParams(window.location.search).has('debug');
      if (urlHasDebug) init = true;
      setState(init);

      if (btn) {
        btn.addEventListener('click', function() {
          setState(!body.classList.contains('debug-outlines'));
        });
      }

      // Expose helper
      try { window.__debugSetState = setState; } catch(e) {}
    })();

    // Toggle de grilla de 12 columnas con modos (Full, 7xl, 5xl, 2xl)
    (function() {
      const KEY = 'gridOverlayOn';
      const KEY_MODE = 'gridOverlayMode';
      const btn = document.getElementById('gridToggleBtn');
      const body = document.body;
      const overlay = document.getElementById('gridOverlay');
      const inner = overlay.querySelector('.grid-overlay-inner');
      const anchors = Array.from(document.querySelectorAll('[data-grid-anchor]'));

      function getActiveAnchor() {
        if (!anchors.length) return null;
        const vh = window.innerHeight || document.documentElement.clientHeight;
        let best = null;
        let bestScore = -1;
        for (const el of anchors) {
          const r = el.getBoundingClientRect();
          const visibleH = Math.max(0, Math.min(r.bottom, vh) - Math.max(r.top, 0));
          const ratio = visibleH / Math.max(1, r.height);
          if (ratio > bestScore) { bestScore = ratio; best = el; }
        }
        return best;
      }

      function alignToAnchor(target) {
        const a = target || getActiveAnchor();
        if (!a) {
          // Fallback: centrar por max-width definido
          inner.style.position = '';
          inner.style.top = '';
          inner.style.bottom = '';
          inner.style.left = '';
          inner.style.width = '';
          inner.style.maxWidth = 'var(--grid-max, 80rem)';
          return;
        }
        const rect = a.getBoundingClientRect();
        inner.style.position = 'fixed';
        inner.style.top = '0px';
        inner.style.bottom = '0px';
        inner.style.left = rect.left + 'px';
        inner.style.width = rect.width + 'px';
        inner.style.maxWidth = 'none';
      }

      const MODES = [
        { id: 'full', label: 'Full', apply: () => { overlay.classList.add('full'); overlay.style.setProperty('--grid-max', '100%'); } },
        { id: '7xl',  label: '7xl',  apply: () => { overlay.classList.remove('full'); overlay.style.setProperty('--grid-max', '80rem'); } },
        { id: '5xl',  label: '5xl',  apply: () => { overlay.classList.remove('full'); overlay.style.setProperty('--grid-max', '64rem'); } },
        { id: '2xl',  label: '2xl',  apply: () => { overlay.classList.remove('full'); overlay.style.setProperty('--grid-max', '42rem'); } },
      ];

      function setModeById(id) {
        const idx = Math.max(0, MODES.findIndex(m => m.id === id));
        const mode = MODES[idx] || MODES[0];
        mode.apply();
        // Alinear al ancla si existe
        try { alignToAnchor(); } catch(e) {}
        updateLabel(body.classList.contains('grid-overlay-on'), mode);
        try { localStorage.setItem(KEY_MODE, mode.id); } catch(e) {}
        return idx;
      }

      function nextMode(currentId) {
        const currentIdx = Math.max(0, MODES.findIndex(m => m.id === currentId));
        const nextIdx = (currentIdx + 1) % MODES.length;
        const mode = MODES[nextIdx];
        mode.apply();
        updateLabel(body.classList.contains('grid-overlay-on'), mode);
        try { localStorage.setItem(KEY_MODE, mode.id); } catch(e) {}
        return nextIdx;
      }

      function updateLabel(enabled, mode) {
        if (!btn) return;
        const suffix = mode ? ` (${mode.label})` : '';
        btn.textContent = enabled ? `Grid: ON${suffix}` : `Grid: OFF${suffix}`;
      }

      function setState(enabled) {
        if (enabled) {
          body.classList.add('grid-overlay-on');
          if (btn) { btn.setAttribute('aria-pressed', 'true'); }
        } else {
          body.classList.remove('grid-overlay-on');
          if (btn) { btn.setAttribute('aria-pressed', 'false'); }
        }
        const modeId = (function(){ try { return localStorage.getItem(KEY_MODE) || '2xl'; } catch(e) { return '2xl'; } })();
        const mode = MODES.find(m => m.id === modeId) || MODES[3];
        updateLabel(enabled, mode);
        try { localStorage.setItem(KEY, enabled ? '1' : '0'); } catch (e) {}
        if (enabled) { try { alignToAnchor(); } catch(e) {} }
      }

      // Init desde localStorage
      let init = false;
      try { init = localStorage.getItem(KEY) === '1'; } catch (e) {}
      let modeId = '2xl';
      try { modeId = localStorage.getItem(KEY_MODE) || '2xl'; } catch(e) {}
      setModeById(modeId);
      setState(init);
      // Recalcular en resize y scroll (con rAF)
      let ticking = false;
      function requestAlign() {
        if (ticking) return;
        ticking = true;
        requestAnimationFrame(function(){
          ticking = false;
          if (body.classList.contains('grid-overlay-on')) { try { alignToAnchor(); } catch(e) {} }
        });
      }
      window.addEventListener('resize', requestAlign);
      window.addEventListener('scroll', requestAlign, { passive: true });

      if (btn) {
        btn.addEventListener('click', function(ev) {
          if (ev.altKey) {
            // Cambiar modo
            try { modeId = localStorage.getItem(KEY_MODE) || '2xl'; } catch(e) { modeId = '2xl'; }
            const nextIdx = nextMode(modeId);
            modeId = MODES[nextIdx].id;
            return;
          }
          // Toggle ON/OFF
          setState(!body.classList.contains('grid-overlay-on'));
        });
      }

      // Expose helper
      try { window.__gridSetState = setState; } catch(e) {}
    })();
  </script>

  <!-- Unified Dev toggle (controls Debug + Grid together) -->
  <script>
    document.addEventListener('DOMContentLoaded', function(){
      var devBtn = document.getElementById('devToggleBtn');
      var body = document.body;

      if (!devBtn) return;

      function states(){
        return {
          debugOn: body.classList.contains('debug-outlines'),
          gridOn: body.classList.contains('grid-overlay-on')
        };
      }

      function updateDevLabel(){
        var s = states();
        var on = s.debugOn && s.gridOn;
        devBtn.setAttribute('aria-pressed', on ? 'true' : 'false');
        devBtn.textContent = on ? 'Dev: ON' : 'Dev: OFF';
      }

      // Initial label
      updateDevLabel();

      // Sync mobile dev button
      var devBtnMobile = document.getElementById('devToggleBtnMobile');
      if (devBtnMobile) {
        devBtnMobile.addEventListener('click', function(){
          var s = states();
          var shouldTurnOn = !(s.debugOn && s.gridOn);
          // Use the same helper functions as the main button
          if (typeof window.__debugSetState === 'function') {
            try { window.__debugSetState(shouldTurnOn); } catch(e) {}
          } else {
            // Fallback toggle
            body.classList.toggle('debug-outlines', shouldTurnOn);
            try { localStorage.setItem('debugOutlines', shouldTurnOn ? '1' : '0'); } catch(e) {}
          }
          if (typeof window.__gridSetState === 'function') {
            try { window.__gridSetState(shouldTurnOn); } catch(e) {}
          } else {
            body.classList.toggle('grid-overlay-on', shouldTurnOn);
            try { localStorage.setItem('gridOverlayOn', shouldTurnOn ? '1' : '0'); } catch(e) {}
          }
          updateDevLabel();
          updateMobileDevLabel();
        });
      }

      function updateMobileDevLabel(){
        if (!devBtnMobile) return;
        var s = states();
        var on = s.debugOn && s.gridOn;
        devBtnMobile.setAttribute('aria-pressed', on ? 'true' : 'false');
        devBtnMobile.textContent = on ? 'Dev: ON' : 'Dev: OFF';
      }

      // Footer toggle for mobile
      var footerToggleBtn = document.getElementById('footerToggleBtn');
      var footerContent = document.getElementById('footerContent');
      var footerToggleIcon = document.getElementById('footerToggleIcon');
      
      if (footerToggleBtn && footerContent && footerToggleIcon) {
        footerToggleBtn.addEventListener('click', function(){
          var isExpanded = footerToggleBtn.getAttribute('aria-expanded') === 'true';
          
          if (isExpanded) {
            footerContent.classList.add('hidden');
            footerToggleBtn.setAttribute('aria-expanded', 'false');
            footerToggleIcon.textContent = 'expand_more';
            footerToggleIcon.style.transform = 'rotate(0deg)';
          } else {
            footerContent.classList.remove('hidden');
            footerToggleBtn.setAttribute('aria-expanded', 'true');
            footerToggleIcon.textContent = 'expand_less';
            footerToggleIcon.style.transform = 'rotate(180deg)';
          }
        });
      }

      devBtn.addEventListener('click', function(){
        var s = states();
        var shouldTurnOn = !(s.debugOn && s.gridOn);
        // Prefer helpers exposed by the modules
        if (typeof window.__debugSetState === 'function') {
          try { window.__debugSetState(shouldTurnOn); } catch(e) {}
        } else {
          // Fallback toggle
          body.classList.toggle('debug-outlines', shouldTurnOn);
          try { localStorage.setItem('debugOutlines', shouldTurnOn ? '1' : '0'); } catch(e) {}
        }
        if (typeof window.__gridSetState === 'function') {
          try { window.__gridSetState(shouldTurnOn); } catch(e) {}
        } else {
          body.classList.toggle('grid-overlay-on', shouldTurnOn);
          try { localStorage.setItem('gridOverlayOn', shouldTurnOn ? '1' : '0'); } catch(e) {}
        }
        setTimeout(function(){
          updateDevLabel();
          updateMobileDevLabel();
        }, 0);
      });
  </script>

  <!-- Punto de extensión para JS extra por página -->
  <th:block layout:fragment="body-scripts"></th:block>
</body>
</html>
